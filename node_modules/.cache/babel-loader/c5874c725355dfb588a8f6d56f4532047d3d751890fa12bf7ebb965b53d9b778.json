{"ast":null,"code":"import * as faceapi from 'face-api.js';\n\n// Function to load models\nexport const loadModels = async () => {\n  try {\n    const MODEL_URL = '/models'; // Path where models are stored\n    await faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL);\n    await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);\n    await faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL);\n    console.log(\"Models loaded successfully.\");\n    return true; // Return true when models are loaded\n  } catch (error) {\n    console.error(\"Error loading models:\", error);\n    return false; // Return false if loading models fails\n  }\n};\n\n// Function to load the initial image for face detection\nexport const loadInitialImage = async isModelLoaded => {\n  if (!isModelLoaded) {\n    console.error(\"Models not loaded. Cannot perform face detection.\");\n    return;\n  }\n  try {\n    const img = await faceapi.fetchImage('/images/initialImage.jpg'); // Use image from the public folder\n    const detections = await faceapi.detectSingleFace(img).withFaceLandmarks().withFaceDescriptor();\n    if (detections) {\n      console.log(\"Initial image processed. Face detected.\");\n    } else {\n      console.error(\"No face detected in the initial image.\");\n    }\n  } catch (error) {\n    console.error(\"Error loading or processing initial image:\", error);\n  }\n};\n\n// Function to compare descriptors\nconst compareFaces = (descriptor1, descriptor2, threshold = 0.6) => {\n  const distance = faceapi.euclideanDistance(descriptor1, descriptor2);\n  return distance < threshold; // Return true if faces match\n};\n\n// Function to start real-time webcam processing\nexport const startWebcamProcessing = async (videoElement, initialDescriptor, onMismatch) => {\n  if (!initialDescriptor) {\n    console.error(\"Initial descriptor is missing. Cannot compare faces.\");\n    return;\n  }\n  if (!videoElement) {\n    console.error(\"Video element not available\");\n    return;\n  }\n  const stream = await navigator.mediaDevices.getUserMedia({\n    video: true\n  });\n  videoElement.srcObject = stream;\n  videoElement.addEventListener('play', async () => {\n    const canvas = faceapi.createCanvasFromMedia(videoElement);\n    document.body.append(canvas);\n    const displaySize = {\n      width: videoElement.width,\n      height: videoElement.height\n    };\n    faceapi.matchDimensions(canvas, displaySize);\n    setInterval(async () => {\n      const detections = await faceapi.detectSingleFace(videoElement).withFaceLandmarks().withFaceDescriptor();\n      if (detections) {\n        const {\n          descriptor\n        } = detections;\n        const isMatching = compareFaces(initialDescriptor, descriptor);\n        if (!isMatching) {\n          onMismatch(); // Trigger mismatch alert\n        }\n      }\n    }, 1000); // Process a frame every second\n  });\n};","map":{"version":3,"names":["faceapi","loadModels","MODEL_URL","nets","ssdMobilenetv1","loadFromUri","faceLandmark68Net","faceRecognitionNet","console","log","error","loadInitialImage","isModelLoaded","img","fetchImage","detections","detectSingleFace","withFaceLandmarks","withFaceDescriptor","compareFaces","descriptor1","descriptor2","threshold","distance","euclideanDistance","startWebcamProcessing","videoElement","initialDescriptor","onMismatch","stream","navigator","mediaDevices","getUserMedia","video","srcObject","addEventListener","canvas","createCanvasFromMedia","document","body","append","displaySize","width","height","matchDimensions","setInterval","descriptor","isMatching"],"sources":["D:/SIH/RecruitSmart/RecruitSmart Frontend/src/components/UserDashboard/Simulation/faceRecognition.js"],"sourcesContent":["import * as faceapi from 'face-api.js';\r\n\r\n\r\n// Function to load models\r\nexport const loadModels = async () => {\r\n    try {\r\n        const MODEL_URL = '/models'; // Path where models are stored\r\n        await faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL);\r\n        await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);\r\n        await faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL);\r\n        console.log(\"Models loaded successfully.\");\r\n        return true; // Return true when models are loaded\r\n    } catch (error) {\r\n        console.error(\"Error loading models:\", error);\r\n        return false; // Return false if loading models fails\r\n    }\r\n};\r\n\r\n// Function to load the initial image for face detection\r\nexport const loadInitialImage = async (isModelLoaded) => {\r\n    if (!isModelLoaded) {\r\n        console.error(\"Models not loaded. Cannot perform face detection.\");\r\n        return;\r\n    }\r\n\r\n    try {\r\n        const img = await faceapi.fetchImage('/images/initialImage.jpg'); // Use image from the public folder\r\n        const detections = await faceapi.detectSingleFace(img).withFaceLandmarks().withFaceDescriptor();\r\n        if (detections) {\r\n            console.log(\"Initial image processed. Face detected.\");\r\n        } else {\r\n            console.error(\"No face detected in the initial image.\");\r\n        }\r\n    } catch (error) {\r\n        console.error(\"Error loading or processing initial image:\", error);\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Function to compare descriptors\r\nconst compareFaces = (descriptor1, descriptor2, threshold = 0.6) => {\r\n    const distance = faceapi.euclideanDistance(descriptor1, descriptor2);\r\n    return distance < threshold; // Return true if faces match\r\n};\r\n\r\n// Function to start real-time webcam processing\r\nexport const startWebcamProcessing = async (videoElement, initialDescriptor, onMismatch) => {\r\n    if (!initialDescriptor) {\r\n        console.error(\"Initial descriptor is missing. Cannot compare faces.\");\r\n        return;\r\n    }\r\n    if (!videoElement) {\r\n        console.error(\"Video element not available\");\r\n        return;\r\n    }\r\n\r\n    const stream = await navigator.mediaDevices.getUserMedia({ video: true });\r\n    videoElement.srcObject = stream;\r\n\r\n    videoElement.addEventListener('play', async () => {\r\n        const canvas = faceapi.createCanvasFromMedia(videoElement);\r\n        document.body.append(canvas);\r\n\r\n        const displaySize = { width: videoElement.width, height: videoElement.height };\r\n        faceapi.matchDimensions(canvas, displaySize);\r\n\r\n        setInterval(async () => {\r\n            const detections = await faceapi\r\n                .detectSingleFace(videoElement)\r\n                .withFaceLandmarks()\r\n                .withFaceDescriptor();\r\n\r\n            if (detections) {\r\n                const { descriptor } = detections;\r\n                const isMatching = compareFaces(initialDescriptor, descriptor);\r\n\r\n                if (!isMatching) {\r\n                    onMismatch(); // Trigger mismatch alert\r\n                }\r\n            }\r\n        }, 1000); // Process a frame every second\r\n    });\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}