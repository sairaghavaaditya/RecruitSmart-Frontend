{"ast":null,"code":"import * as faceapi from 'face-api.js';\n\n// Function to load models\nexport const loadModels = async () => {\n  try {\n    const MODEL_URL = '/models'; // Path where models are stored\n    await faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL);\n    await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);\n    await faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL);\n    console.log(\"Models loaded successfully.\");\n    return true; // Return true when models are loaded\n  } catch (error) {\n    console.error(\"Error loading models:\", error);\n    return false; // Return false if loading models fails\n  }\n};\n\n// Function to load the initial image for face detection\nexport const loadInitialImage = async isModelLoaded => {\n  if (!isModelLoaded) {\n    console.error(\"Models not loaded. Cannot perform face detection.\");\n    return;\n  }\n  try {\n    const img = await faceapi.fetchImage('/images/initialImage.jpg'); // Use image from the public folder\n    const detections = await faceapi.detectSingleFace(img).withFaceLandmarks().withFaceDescriptor();\n    if (detections) {\n      console.log(\"Initial image processed. Face detected.\");\n      return detections.descriptor; // Return the descriptor of the initial face\n    } else {\n      console.error(\"No face detected in the initial image.\");\n    }\n  } catch (error) {\n    console.error(\"Error loading or processing initial image:\", error);\n  }\n};\n\n// Function to compare descriptors\nconst compareFaces = (descriptor1, descriptor2, threshold = 0.6) => {\n  const distance = faceapi.euclideanDistance(descriptor1, descriptor2);\n  return distance < threshold; // Return true if faces match\n};\n\n// Function to start real-time webcam processing\nexport const startWebcamProcessing = async (webcamRef, initialDescriptor, onMismatch) => {\n  if (!initialDescriptor) {\n    console.error(\"Initial descriptor is missing. Cannot compare faces.\");\n    return;\n  }\n  if (!webcamRef.current) {\n    console.error(\"Webcam reference is not available.\");\n    return;\n  }\n\n  // Start the webcam stream and capture frames\n  setInterval(async () => {\n    // Get the current screenshot from the webcam\n    const screenshot = webcamRef.current.getScreenshot();\n    if (screenshot) {\n      // Process the screenshot using face-api.js\n      const detections = await faceapi.detectSingleFace(screenshot).withFaceLandmarks().withFaceDescriptor();\n      if (detections) {\n        const {\n          descriptor\n        } = detections;\n        const isMatching = compareFaces(initialDescriptor, descriptor);\n        if (!isMatching) {\n          console.log(\"Face mismatch detected\");\n          onMismatch(); // Trigger mismatch alert\n        }\n      } else {\n        console.log(\"No face detected in the webcam frame\");\n      }\n    }\n  }, 1000); // Process a frame every second\n};","map":{"version":3,"names":["faceapi","loadModels","MODEL_URL","nets","ssdMobilenetv1","loadFromUri","faceLandmark68Net","faceRecognitionNet","console","log","error","loadInitialImage","isModelLoaded","img","fetchImage","detections","detectSingleFace","withFaceLandmarks","withFaceDescriptor","descriptor","compareFaces","descriptor1","descriptor2","threshold","distance","euclideanDistance","startWebcamProcessing","webcamRef","initialDescriptor","onMismatch","current","setInterval","screenshot","getScreenshot","isMatching"],"sources":["D:/SIH/RecruitSmart/RecruitSmart Frontend/src/components/UserDashboard/Simulation/faceRecognition.js"],"sourcesContent":["import * as faceapi from 'face-api.js';\r\n\r\n// Function to load models\r\nexport const loadModels = async () => {\r\n    try {\r\n        const MODEL_URL = '/models'; // Path where models are stored\r\n        await faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL);\r\n        await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);\r\n        await faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL);\r\n        console.log(\"Models loaded successfully.\");\r\n        return true; // Return true when models are loaded\r\n    } catch (error) {\r\n        console.error(\"Error loading models:\", error);\r\n        return false; // Return false if loading models fails\r\n    }\r\n};\r\n\r\n// Function to load the initial image for face detection\r\nexport const loadInitialImage = async (isModelLoaded) => {\r\n    if (!isModelLoaded) {\r\n        console.error(\"Models not loaded. Cannot perform face detection.\");\r\n        return;\r\n    }\r\n\r\n    try {\r\n        const img = await faceapi.fetchImage('/images/initialImage.jpg'); // Use image from the public folder\r\n        const detections = await faceapi.detectSingleFace(img).withFaceLandmarks().withFaceDescriptor();\r\n        if (detections) {\r\n            console.log(\"Initial image processed. Face detected.\");\r\n            return detections.descriptor; // Return the descriptor of the initial face\r\n        } else {\r\n            console.error(\"No face detected in the initial image.\");\r\n        }\r\n    } catch (error) {\r\n        console.error(\"Error loading or processing initial image:\", error);\r\n    }\r\n};\r\n\r\n// Function to compare descriptors\r\nconst compareFaces = (descriptor1, descriptor2, threshold = 0.6) => {\r\n    const distance = faceapi.euclideanDistance(descriptor1, descriptor2);\r\n    return distance < threshold; // Return true if faces match\r\n};\r\n\r\n// Function to start real-time webcam processing\r\nexport const startWebcamProcessing = async (webcamRef, initialDescriptor, onMismatch) => {\r\n    if (!initialDescriptor) {\r\n        console.error(\"Initial descriptor is missing. Cannot compare faces.\");\r\n        return;\r\n    }\r\n\r\n    if (!webcamRef.current) {\r\n        console.error(\"Webcam reference is not available.\");\r\n        return;\r\n    }\r\n\r\n    // Start the webcam stream and capture frames\r\n    setInterval(async () => {\r\n        // Get the current screenshot from the webcam\r\n        const screenshot = webcamRef.current.getScreenshot();\r\n\r\n        if (screenshot) {\r\n            // Process the screenshot using face-api.js\r\n            const detections = await faceapi.detectSingleFace(screenshot).withFaceLandmarks().withFaceDescriptor();\r\n\r\n            if (detections) {\r\n                const { descriptor } = detections;\r\n                const isMatching = compareFaces(initialDescriptor, descriptor);\r\n\r\n                if (!isMatching) {\r\n                    console.log(\"Face mismatch detected\");\r\n                    onMismatch(); // Trigger mismatch alert\r\n                }\r\n            } else {\r\n                console.log(\"No face detected in the webcam frame\");\r\n            }\r\n        }\r\n    }, 1000); // Process a frame every second\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}